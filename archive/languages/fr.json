{
	"tt52up": "Générer des identifiants uniques courts",
	"tt75ra": "{name}{pronounced} est une bibliothèque open source qui vous permet de générer des identifiants courts uniques à partir de nombres. Ces identifiants sont sûrs pour les URL, peuvent encoder plusieurs nombres et ne contiennent pas de mots grossiers courants.",
	"ttd0n6": "Lire la suite",
	"ttf0dj": "Voici à quoi ils ressemblent :",
	"ttspqb": "Cas d'utilisation",
	"tt810r": "L'utilisation principale de {name} est purement visuelle. Si vous souhaitez utiliser des identifiants au lieu de nombres dans votre projet, {name} pourrait être un bon choix.",
	"ttfxdj": "Bons pour",
	"ttcn90": "Pas bons pour",
	"ttxrw3": "Encodage des clés primaires",
	"ttblk8": "Si vous utilisez une base de données relationnelle",
	"ttw5eb": "Économie de recherches dans la base de données",
	"ttrzg4": "En encodant plusieurs objets",
	"ttj376": "Jetons de connexion temporaires",
	"ttor8c": "Sans grossièretés et sûr pour les URL",
	"ttzbtd": "Données sensibles",
	"tt3bzl": "Ce n'est pas une bibliothèque de chiffrement",
	"ttm1yo": "Identifiants utilisateur",
	"ttt7ff": "Peut révéler le nombre d'utilisateurs si quelqu'un découvre l'alphabet de codage",
	"tte6as": "FAQ",
	"ttl1c7": "Espace de jeu",
	"ttgq43": "Langue",
	"ttaf1b": "Fonctionnalités",
	"ttz5td": "Générer des identifiants courts à partir de nombres non négatifs",
	"ttncim": "Encodage et décodage faciles",
	"ttimoo": "Les identifiants générés ne contiennent pas de grossièretés courantes",
	"tty56c": "Support des identifiants personnalisés via un alphabet mélangé",
	"tt6v30": "Chaque version produit les mêmes identifiants",
	"tthejy": "Petite bibliothèque avec une licence permissive",
	"tt0ds2": "{count} langages de programmation ({new} utilisant un nouveau design)",
	"tt9vmk": "Commencer",
	"ttpebs": "Quelle langue utilisez-vous ?",
	"ttkph9": "Impossible de le trouver",
	"tt1ap4": "Faites-nous savoir à ce sujet ?",
	"tt445i": "Exemple",
	"ttqewx": "Alphabet",
	"tttnnf": "Nombres",
	"tt52lu": "Identifiant généré",
	"tt74ur": "mélanger",
	"ttdosn": "Mélanger",
	"ttfisd": "nouveau",
	"ttswbq": "Proposez une modification de traduction de texte",
	"tt8qp0": "Parrainer",
	"ttfiwd": "Populaire",
	"ttcyi9": "Poser une question",
	"ttxagw": "Trouvé un bug ?",
	"ttbjck": "{name} a été mis à jour et rebrandé",
	"ttw1ue": "Mettre une étoile sur {what} sur {github}",
	"ttr5tg": "Exemple rapide d'encodage et de décodage :",
	"ttjgz7": "Si les identifiants sont trop courts, vous pouvez les compléter jusqu'à une certaine longueur :",
	"ttosg8": "Créer des identifiants uniques en mélangeant l'alphabet :",
	"ttzdkt": "La documentation complète est disponible à",
	"tt3fkz": "Commencer",
	"ttm3py": "Si vous recherchez l'{name} original, vous pouvez le trouver ici :",
	"tttnrf": "{name} pour {lang} n'est pas encore prêt.",
	"ttep3a": "Veuillez mettre une étoile sur le dépôt pour le faire monter dans notre liste de tâches :",
	"ttlmpc": "Si vous souhaitez contribuer à donner vie à cette version, il y a une section FAQ sur comment faire :",
	"ttgux4": "Comment porter {name} vers une autre langue ?",
	"ttabd1": "Si vous recherchez le projet original {name}, vous pouvez le trouver ici :",
	"ttzdut": "Veuillez noter qu'il ne sera pas compatible avec l'algorithme actuel une fois que cette version sera terminée.",
	"ttn89i": "{name} est une bibliothèque open source qui vous permet de générer des identifiants uniques à partir de nombres. Elle prend en charge {count} langages de programmation.",
	"tti0yo": "Identifiants uniques courts en {lang}",
	"ttyzu6": "Générez des identifiants uniques courts en {lang} à l'aide de {name}. Ces identifiants sont sécurisés pour les URL, peuvent encoder plusieurs nombres et ne contiennent pas de mots grossiers courants.",
	"tt6t23": "Aire de jeux {name}. Explorez la bibliothèque d'encodage et de décodage {name}.",
	"tthraj": "Foire aux questions pour {name}.",
	"tt0xns": "Longueur minimale",
	"tt962m": "Liste noire",
	"ttphab": "Ajoutez vos propres mots personnalisés séparés par des espaces...",
	"ttk7bh": "Utilisez également la liste noire par défaut",
	"tt1k1p": "Alphabet par défaut",
	"tt42u5": "Court",
	"ttqaex": "Long",
	"tttiif": "Lettres",
	"tt5lcu": "Minuscules",
	"tt75vr": "Majuscules",
	"ttd8qn": "Liste",
	"ttfoqd": "Encoder",
	"ttsekq": "Décoder",
	"tt8xb0": "Encoder plusieurs",
	"ttfoed": "Encoder un zéro supplémentaire",
	"ttc6o9": "Encoder une grande constante",
	"ttx14w": "Identifiant",
	"ttb79k": "Encodage de ces nombres :",
	"ttwpve": "Produira :",
	"ttrufg": "Décodage de cet identifiant :",
	"ttj4t7": "L'alphabet doit comporter au moins {count} caractères",
	"ttoq48": "Les espaces dans l'alphabet seront ignorés",
	"ttznht": "Les mots de la liste noire de moins de {count} caractères seront ignorés",
	"tt3dhz": "bloc",
	"ttmzby": "Général",
	"tttigf": "À quoi cela sert-il ?",
	"ttebza": "Pourquoi cela ne convient-il pas ?",
	"ttlybc": "Est-ce que je peux encoder plusieurs nombres en même temps ?",
	"ttgvw4": "Les identifiants générés sont-ils uniques ?",
	"ttakn1": "Quelles limitations {name} a-t-il ?",
	"ttznvt": "Contribuer",
	"ttn0mi": "Pièges",
	"ttis6o": "Remplissage",
	"ttytv6": "Comment puis-je rendre mes identifiants uniques ?",
	"tt6fl3": "Comment puis-je mélanger l'alphabet par défaut ?",
	"tthg1j": "Est-il préférable d'utiliser un alphabet plus court ou plus long ?",
	"tt0wis": "Mon alphabet peut-il être composé uniquement de chiffres ?",
	"tt93lm": "Puis-je utiliser des emojis comme alphabet ?",
	"ttpj1b": "Pourquoi remplir les identifiants ?",
	"ttkrkh": "Puis-je rendre les identifiants générés plus longs ?",
	"tt1jbp": "Puis-je définir une longueur spécifique pour les identifiants générés ?",
	"tt4lv5": "Pourquoi utiliser une liste noire ?",
	"ttq1ax": "Comment fonctionne la liste noire ?",
	"tttoof": "Quels mots sont dans la liste noire par défaut ?",
	"tt5c9u": "Que se passe-t-il lorsque tous les identifiants sont bloqués ?",
	"tt7u2r": "Comment vérifier si les identifiants sont valides ?",
	"ttd0xn": "Que se passe-t-il lorsque la liste noire par défaut est mise à jour ?",
	"ttf8xd": "Est-ce que l'encodage de différents nombres peut produire des identifiants identiques ?",
	"ttsahq": "Qu'est-ce que {name} ?",
	"tt8wk0": "Pourquoi {hashids} a-t-il été mis à niveau vers {name} ?",
	"ttf8ad": "Pourquoi le paramètre {salt} a-t-il été supprimé ?",
	"ttc389": "Est-ce que {hashids} est compatible avec {name} ?",
	"ttxp5w": "Comment puis-je effectuer une mise à niveau sûre de {hashids} vers {name} ?",
	"ttbrmk": "Où puis-je trouver les bibliothèques originales {hashids} ?",
	"ttwb2e": "Comment puis-je contribuer ?",
	"ttrvdg": "Comment porter {name} vers une autre langue ?",
	"ttj5f7": "{name} est une petite bibliothèque open-source qui peut produire des identifiants courts, uniques et ayant l'apparence du hasard à partir de nombres.",
	"ttox58": "Le meilleur moyen de le comprendre est de le considérer comme un convertisseur décimal en hexadécimal, mais avec quelques fonctionnalités supplémentaires.",
	"ttzijt": "Raccourcir les liens, générer des identifiants uniques pour le suivi, générer des identifiants pour les produits/objets sur un site web (comme le fait YouTube pour les vidéos), générer des identifiants courts pour les SMS, codes de confirmation dans les e-mails, etc.",
	"tt3njz": "Toute donnée sensible. Les identifiants générés ne sont pas des hachages et pourraient être décodés en nombres. Par exemple, ils pourraient ne pas être un bon choix pour les identifiants d'utilisateurs, car une fois décodés, ils pourraient révéler le nombre d'utilisateurs de votre application.",
	"ttmtky": "Oui. {name} peut encoder un ou plusieurs nombres non négatifs dans un seul identifiant. Il n'y a pas de limite au nombre de nombres que vous pouvez encoder, mais il y a une limite à la taille du nombre que vous pouvez encoder (en fonction du langage d'implémentation).",
	"ttto4f": "Cela est utile pour plusieurs raisons : vous pourriez encoder un horodatage UNIX et créer des identifiants expirant, ou vous pourriez encoder un numéro de fragment de base de données avec une clé primaire et économiser des requêtes supplémentaires à la base de données.",
	"ttekta": "Oui, les identifiants générés sont uniques pour l'entrée et l'alphabet.",
	"ttl6kc": "Gardez à l'esprit que l'alphabet par défaut contient des lettres majuscules et minuscules, donc les identifiants par défaut sont sensibles à la casse.",
	"ttg2e4": "{name} ne peut pas encoder de nombres négatifs.",
	"ttahi1": "La longueur minimale de l'alphabet est de {length} caractères.",
	"ttzi2t": "L'alphabet ne peut contenir aucun caractère multibyte.",
	"ttnsyi": "{name} ne peut pas générer d'identifiants jusqu'à une certaine longueur, seulement à partir d'une certaine longueur. La plage du paramètre de longueur minimale est entre {min} et {max}.",
	"ttiq3o": "{name} peut tenter de régénérer des identifiants jusqu'à la longueur de l'alphabet, moins un.",
	"ttyf26": "La bibliothèque accepte un alphabet personnalisé à partir duquel elle peut générer des identifiants. Pré-mélangez simplement l'alphabet par défaut qui est fourni.",
	"tt6dc3": "Gardez à l'esprit qu'avec suffisamment d'efforts, quelqu'un pourrait rétro-ingénier votre alphabet mélangé, donc ce n'est en aucun cas une technique pour cacher des données sensibles.",
	"tth4pj": "L'alphabet par défaut peut être trouvé [ici]({url}).",
	"tt0eos": "Vous pouvez utiliser n'importe quel outil en ligne de mélange de chaînes ou notre [plateforme d'essai](/playground).",
	"tt9zcm": "Dépend de votre cas d'utilisation. Un alphabet plus court produira des identifiants plus longs, et un alphabet plus long produira des identifiants plus courts. Vous pouvez utiliser le [plateforme d'essai](/playground) pour voir à quoi pourraient ressembler vos identifiants.",
	"ttp7pb": "Oui. Gardez à l'esprit que les identifiants générés sont toujours des chaînes et peuvent commencer par un zéro.",
	"ttk4jh": "Non. {name} ne prend pas en charge les caractères multibyte pour l'alphabet. Cela inclut les emojis ainsi que de nombreux autres caractères.",
	"tt17kp": "La bibliothèque peut étendre les identifiants avec des caractères superflus pour les rendre plus longs. C'est utile pour qu'il ne soit pas aussi évident si vous encodez un petit nombre comme {min} ou un grand nombre comme {max}.",
	"tt4c25": "Le décodage n'est pas affecté.",
	"ttqp1x": "Oui, la bibliothèque accepte un paramètre de longueur minimale qui garantit que les identifiants auront au moins cette longueur.",
	"ttt88f": "Veuillez noter qu'il n'y a aucune garantie sur la longueur de vos identifiants, seulement qu'ils ne seront pas plus courts que la longueur que vous spécifiez.",
	"tt59mu": "Jusqu'à un certain point.",
	"tt7vlr": "Définir une longueur maximale est impossible car tôt ou tard vos identifiants déborderont avec une entrée suffisamment grande. C'est pourquoi seul le paramètre de longueur minimale est pris en charge, et la longueur exacte ou maximale ne l'est pas.",
	"ttdswn": "Une liste noire peut empêcher certains mots d'apparaître dans vos identifiants. C'est bénéfique car les identifiants générés sont destinés à apparaître dans des endroits publics, comme l'URL.",
	"ttf0wd": "{name} est livré avec la [liste noire par défaut]({url}) qui contient les mots vulgaires et inappropriés les plus basiques de plusieurs langues. Vous pouvez bien sûr étendre cette liste noire avec vos propres mots.",
	"tts1jq": "La correspondance des mots de la liste noire n'est pas sensible à la casse.",
	"tt8eh0": "Les mots courts de moins de 3 caractères ne seront pas bloqués. Les mots de 3 caractères doivent correspondre exactement aux identifiants. Les mots de 4 caractères ou plus déclencheront une correspondance s'ils sont une sous-chaîne de l'identifiant.",
	"ttf01d": "Si les mots de la liste noire contiennent des chiffres (leetspeak), ils ne déclencheront une correspondance que s'ils sont au début ou à la fin de l'identifiant.",
	"ttcz09": "La liste noire par défaut contient les mots vulgaires et inappropriés les plus courants de plusieurs langues. Vous pouvez trouver la liste complète [ici]({url}).",
	"ttxbuw": "Lorsque l'identifiant généré correspond à un mot de la liste noire, la bibliothèque tente de le régénérer.",
	"ttbgyk": "Si chaque tentative de régénération échoue, la fonction d'encodage échouera et renverra une erreur. La gestion de cette erreur relève de l'utilisateur.",
	"ttwkle": "Le meilleur moyen de réduire le nombre de tentatives de régénération est d'avoir un alphabet plus long, de ne pas définir de longueur minimale et de fournir une liste noire plus petite. Fournir une liste noire vide désactivera complètement la fonction.",
	"ttr2ng": "Le décodage des identifiants produira généralement une sorte de sortie numérique, mais cela ne signifie pas nécessairement que l'identifiant est canonique. Pour vérifier que l'identifiant est valide, vous pouvez réencoder les nombres décodés et vérifier que l'identifiant correspond.",
	"ttjud7": "La raison pour laquelle cela n'est pas fait automatiquement est que si la liste noire par défaut change à l'avenir, nous ne voulons pas invalider automatiquement l'identifiant qui a été généré dans le passé et qui pourrait maintenant correspondre à un nouveau mot de la liste noire.",
	"ttowu8": "Nous veillerons à mettre à jour le {changelog} si la liste noire par défaut change.",
	"ttzo7t": "Vous devez tenir compte des scénarios où un nouveau mot pourrait être ajouté à la liste noire par défaut. Dans ce cas, réencoder les nombres peut produire un identifiant différent.",
	"tt3i7z": "Le meilleur moyen de garantir que vos identifiants restent cohérents lors de futures mises à jour est de fournir une liste noire personnalisée, même si elle est identique à la liste noire actuelle par défaut.",
	"ttmfhy": "Non, encoder différents nombres produira des identifiants uniques.",
	"ttt85f": "Cependant, en raison de la conception de l'algorithme, le décodage d'identifiants aléatoires peut parfois produire les mêmes nombres. Le meilleur moyen de vérifier si l'identifiant est canonique est simplement de réencoder les nombres décodés et de vérifier que l'identifiant correspond.",
	"ttehfa": "{hashids} était la première version de cette bibliothèque sortie vers 2013. Elle produisait également des identifiants courts mais utilisait une méthode légèrement différente.",
	"ttl3hc": "{hashids} gérait quelques éléments différemment.",
	"ttgla4": "Elle ne prenait pas en charge une liste noire personnalisée, mais s'appuyait plutôt sur les mots vulgaires anglais les plus courants. Elle utilisait également le paramètre {salt} pour mélanger l'alphabet, ce qui la rendait un peu confuse car la bibliothèque n'avait rien à voir avec le chiffrement. De plus, elle utilisait trop de caractères réservés, ce qui produisait des identifiants plus longs.",
	"ttajo1": "C'est pourquoi nous avons décidé de mettre à niveau et de revoir la marque. L'algorithme a été simplifié, quelques fonctionnalités ont été ajoutées et les dépôts de code sont désormais [regroupés sous un même toit]({url}).",
	"ttzolt": "Le paramètre {salt} était utilisé pour mélanger l'alphabet, et il n'était jamais destiné à être associé à la sécurité. {hashids} et {name} fonctionnent tous deux de manière similaire à la conversion décimale en hexadécimale mais avec quelques ajustements. Il n'y a aucun chiffrement de quelque nature que ce soit, donc pour éviter toute confusion, ce paramètre a été complètement supprimé.",
	"ttnq6i": "Non, {name} étend les fonctionnalités de {hashids} et a des objectifs de conception et des exigences différents ; par conséquent, les identifiants générés ne sont pas compatibles avec {hashids}.",
	"ttixzo": "Comme il n'y a pas de compatibilité entre {hashids} et {name}, il est impossible de simplement remplacer {hashids} par {name}.",
	"ttydl6": "Cependant, vous pouvez fusionner les deux en différenciant quel identifiant appartient à quelle bibliothèque.",
	"tt6n93": "Une des façons de le faire est par la longueur de l'identifiant - si vous passez à {name}, vous pouvez fournir une longueur minimale plus grande. Une autre façon est d'ajouter manuellement un caractère personnalisé aux identifiants nouvellement générés.",
	"tth5bj": "Enfin, vous pouvez également essayer de décoder un identifiant avec {hashids} pour voir s'il est valide. Sinon - décodez et réencodez avec {name} pour voir si cela fonctionne.",
	"tt0a8s": "Chaque implémentation linguistique sur ce site renvoie au dépôt original de {hashids} s'il existe.",
	"tt9t9m": "Si vous souhaitez soutenir le projet, nous apprécierions que vous ajoutiez une étoile à nos dépôts sur Github pour plus de visibilité.",
	"ttpgkb": "Si vous êtes développeur et ne trouvez pas d'implémentation de {name} pour un langage particulier, aidez-nous à convertir la bibliothèque. Il en va de même pour un langage de programmation qui n'est pas répertorié.",
	"ttk57h": "Si vous voyez un bogue dans la spécification ou l'une des implémentations, veuillez créer un problème ou une demande de fusion avec une correction suggérée dans le dépôt approprié.",
	"tt1rhp": "Si vous parlez plusieurs langues, nous pourrions avoir besoin de votre aide pour [ajuster la liste noire]({blocklist}) et [adapter les traductions du site]({i18n}) si vous constatez des problèmes.",
	"tt49l5": "Enfin, si vous avez de l'expérience avec {hashids}/{name}, aidez à guider notre communauté en répondant à toute question que quelqu'un pourrait avoir.",
	"ttqbpx": "Si vous souhaitez porter {name} vers l'un des langages suivants (ou un nouveau non répertorié ici) :",
	"ttt00f": "Faites une copie du dépôt officiel sur votre compte Github et implémentez [la spécification]({spec}) ainsi que tous les tests. Vous pouvez réutiliser l'un des README existants ([exemple]({example})).",
	"tt5myu": "Une fois la bibliothèque prête, créez une demande de fusion. Une fois fusionné, nous mettrons à jour le site.",
	"tt72cr": "Si le dépôt n'a pas de mainteneurs actifs, nous serions heureux de vous inviter à gérer le dépôt et à devenir un mainteneur officiel.",
	"ttdqen": "Si vous êtes un expert dans les domaines suivants, veuillez nous contacter si vous souhaitez porter la bibliothèque :",
	"ttfsed": "Non trouvé",
	"ttsp7q": "Autres langues"
}
