{
	"tt52up": "Gerar IDs Únicos Curtos",
	"tt75ra": "{name}{pronounced} é uma biblioteca de código aberto que permite gerar identificadores únicos curtos a partir de números. Esses IDs são seguros para URLs, podem codificar vários números e não contêm palavras de baixo calão comuns.",
	"ttd0n6": "Leia mais",
	"ttf0dj": "Assim é como eles se parecem:",
	"ttspqb": "Casos de Uso",
	"tt810r": "O principal uso de {name} é puramente visual. Se você deseja usar IDs em vez de números em seu projeto, {name} pode ser uma boa escolha.",
	"ttfxdj": "Bom Para",
	"ttcn90": "Não É Bom Para",
	"ttxrw3": "Codificação de Chaves Primárias",
	"ttblk8": "Se estiver usando um banco de dados relacional",
	"ttw5eb": "Economizando consultas ao banco de dados",
	"ttrzg4": "Codificando vários objetos",
	"ttj376": "Tokens temporários de login",
	"ttor8c": "Livre de palavrões e seguro para URLs",
	"ttzbtd": "Dados Sensíveis",
	"tt3bzl": "Esta não é uma biblioteca de criptografia",
	"ttm1yo": "IDs de Usuário",
	"ttt7ff": "Pode revelar a contagem de usuários se alguém descobrir o alfabeto de codificação",
	"tte6as": "Perguntas",
	"ttl1c7": "Playground",
	"ttgq43": "Biblioteca",
	"ttaf1b": "Recursos",
	"ttz5td": "Gerar IDs curtos a partir de números não negativos",
	"ttncim": "Codificação e decodificação fáceis",
	"ttimoo": "IDs autogerados não contêm palavrões comuns",
	"tty56c": "Suporte para IDs personalizados através de um alfabeto embaralhado",
	"tt6v30": "Cada versão produz os mesmos IDs",
	"tthejy": "Biblioteca pequena com uma licença permissiva",
	"tt0ds2": "{count} integrações ({new} usando novo design)",
	"tt9vmk": "Começar",
	"ttpebs": "O que você está usando?",
	"ttkph9": "Não consegue encontrar?",
	"tt1ap4": "Nos avise sobre isso?",
	"tt445i": "Exemplo",
	"ttqewx": "Alfabeto",
	"tttnnf": "Números",
	"tt52lu": "ID Gerado",
	"tt74ur": "embaralhar",
	"ttdosn": "Embaralhar",
	"ttfisd": "novo",
	"ttswbq": "Sugerir edição na tradução do texto",
	"tt8qp0": "Patrocinar",
	"ttfiwd": "Popular",
	"ttcyi9": "Faça uma pergunta",
	"ttxagw": "Encontrou um bug?",
	"ttbjck": "{name} foi atualizado e reestilizado",
	"ttw1ue": "Dê uma estrela para {what} no {github}",
	"ttr5tg": "Exemplo rápido de codificação e decodificação:",
	"ttjgz7": "Se os IDs forem muito curtos, você pode preenchê-los até um certo comprimento:",
	"ttosg8": "Crie IDs únicos embaralhando o alfabeto:",
	"ttzdkt": "A documentação completa está em",
	"tt3fkz": "Comece",
	"ttm3py": "Se você está procurando pelo {name} original, você pode encontrá-lo aqui:",
	"tttnrf": "{name} para {lang} ainda não está pronto.",
	"ttep3a": "Por favor, dê uma estrela ao repositório para movê-lo para cima na nossa lista de afazeres:",
	"ttlmpc": "Se você gostaria de ajudar a trazer esta versão à vida, há uma seção de perguntas frequentes sobre como fazer isso:",
	"ttgux4": "Como portar {name} para outro idioma?",
	"ttabd1": "Se você está procurando pelo projeto original {name}, você pode encontrá-lo aqui:",
	"ttzdut": "Por favor, note que não será compatível com o algoritmo atual assim que esta versão estiver pronta.",
	"ttn89i": "{name} é uma biblioteca de código aberto que permite gerar IDs únicos curtos a partir de números. Ele suporta {count} linguagens de programação.",
	"tti0yo": "IDs Únicos Curtos em {lang}",
	"ttyzu6": "Gerar IDs únicos curtos em {lang} usando {name}. Esses identificadores são seguros para URLs, podem codificar vários números e não contêm palavras de baixo calão comuns.",
	"tt6t23": "Playground de {name}. Explore a codificação e decodificação de {name}.",
	"tthraj": "Perguntas frequentes para {name}.",
	"tt0xns": "Comprimento Mínimo",
	"tt962m": "Lista de Bloqueio",
	"ttphab": "Adicione suas próprias palavras personalizadas separadas por espaços...",
	"ttk7bh": "Use também a lista de bloqueio padrão",
	"tt1k1p": "Padrão",
	"tt42u5": "Curto",
	"ttqaex": "Longo",
	"tttiif": "Letras",
	"tt5lcu": "Minúsculas",
	"tt75vr": "Maiúsculas",
	"ttd8qn": "Lista",
	"ttfoqd": "Codificar",
	"ttsekq": "Decodificar",
	"tt8xb0": "Codificar múltiplos",
	"ttfoed": "Codificar um zero extra",
	"ttc6o9": "Codificar uma constante grande",
	"ttx14w": "ID",
	"ttb79k": "Codificando estes números:",
	"ttwpve": "Vai produzir:",
	"ttrufg": "Decodificando este ID:",
	"ttj4t7": "O alfabeto deve ter pelo menos {count} caracteres",
	"ttoq48": "Os espaços no alfabeto serão ignorados",
	"ttznht": "Palavras na lista de bloqueio com menos de {count} caracteres serão ignoradas",
	"tt3dhz": "bloquear",
	"ttmzby": "Geral",
	"tttigf": "Para que serve?",
	"ttebza": "Para que não serve?",
	"ttlybc": "Posso codificar vários números de uma vez?",
	"ttgvw4": "Os IDs gerados são únicos?",
	"ttakn1": "Quais são as limitações do {name}?",
	"ttznvt": "Contribuir",
	"ttn0mi": "Problemas",
	"ttis6o": "Preenchimento",
	"ttytv6": "Como posso tornar meus IDs únicos?",
	"tt6fl3": "Como posso embaralhar o alfabeto padrão?",
	"tthg1j": "É melhor usar um alfabeto mais curto ou mais longo?",
	"tt0wis": "O alfabeto pode consistir apenas em números?",
	"tt93lm": "Posso usar emojis como o alfabeto?",
	"ttpj1b": "Por que preencher IDs?",
	"ttkrkh": "Posso tornar os IDs gerados mais longos?",
	"tt1jbp": "Posso fazer os IDs gerados terem um comprimento específico?",
	"tt4lv5": "Por que usar uma lista de bloqueio?",
	"ttq1ax": "Como funciona a lista de bloqueio?",
	"tttoof": "Quais palavras estão na lista de bloqueio padrão?",
	"tt5c9u": "O que acontece quando todos os IDs são bloqueados?",
	"tt7u2r": "Como verificar se os IDs são válidos?",
	"ttd0xn": "O que acontece quando a lista de bloqueio padrão é atualizada?",
	"ttf8xd": "Codificar números diferentes pode produzir IDs idênticos?",
	"ttsahq": "O que é {name}?",
	"tt8wk0": "Por que {hashids} foi atualizado para {name}?",
	"ttf8ad": "Por que o parâmetro {salt} foi removido?",
	"ttc389": "{hashids} é compatível com {name}?",
	"ttxp5w": "Como posso fazer o upgrade de forma segura de {hashids} para {name}?",
	"ttbrmk": "Onde posso encontrar as bibliotecas originais do {hashids}?",
	"ttwb2e": "Como posso contribuir?",
	"ttrvdg": "Como portar {name} para outro idioma?",
	"ttj5f7": "{name} é uma pequena biblioteca de código aberto que pode produzir IDs curtos, únicos e com aparência aleatória a partir de números.",
	"ttox58": "A melhor maneira de pensar sobre isso é como um conversor decimal para hexadecimal, mas com alguns recursos extras.",
	"ttzijt": "Encurtamento de links, geração de IDs de eventos únicos para registro, geração de IDs para produtos/objetos em um site (como o YouTube faz para vídeos), geração de IDs curtos para mensagens de texto, códigos de confirmação em e-mails, etc.",
	"tt3njz": "Quaisquer dados que sejam sensíveis. IDs gerados não são hashes e podem ser decodificados de volta para números. Por exemplo, eles podem não ser uma boa escolha para IDs de usuário, porque uma vez decodificados, podem revelar a contagem de usuários do seu aplicativo.",
	"ttmtky": "Sim. {name} pode codificar um ou muitos números não negativos em um único ID. Não há limite para quantos números você pode codificar, mas há um limite para o tamanho do número que você pode codificar (dependendo da linguagem de implementação).",
	"ttto4f": "Isso é útil por várias razões: você pode codificar um carimbo de data/hora UNIX e criar IDs que expiram, ou você pode codificar um número de fragmento de banco de dados junto com uma chave primária e economizar em consultas extras ao banco de dados.",
	"ttekta": "Sim, os IDs gerados são únicos para a entrada e para o alfabeto.",
	"ttl6kc": "Lembre-se, porém, de que o alfabeto padrão contém letras maiúsculas e minúsculas, então os IDs padrão são sensíveis a maiúsculas e minúsculas.",
	"ttg2e4": "{name} não pode codificar números negativos.",
	"ttahi1": "O comprimento mínimo do alfabeto é de {length} caracteres.",
	"ttzi2t": "O alfabeto não pode conter caracteres multibyte.",
	"ttnsyi": "{name} não pode gerar IDs de um comprimento específico, apenas no mínimo de um certo comprimento. O intervalo do parâmetro de comprimento mínimo varia entre {min} e {max}.",
	"ttiq3o": "{name} pode tentar regenerar IDs até o comprimento do alfabeto, menos um.",
	"ttyf26": "A biblioteca aceita um alfabeto personalizado a partir do qual pode gerar IDs. Basta pré-embaralhar o alfabeto padrão fornecido.",
	"tt6dc3": "Por favor, tenha em mente que, com esforço suficiente, alguém poderia fazer engenharia reversa do seu alfabeto embaralhado, então esta não é de forma alguma uma técnica para esconder dados sensíveis.",
	"tth4pj": "O alfabeto padrão pode ser encontrado [aqui]({url}).",
	"tt0eos": "Você pode usar qualquer uma das ferramentas online de embaralhamento de strings ou o nosso [playground](/playground).",
	"tt9zcm": "Depende do seu caso de uso. Um alfabeto mais curto produzirá IDs mais longos e um alfabeto mais longo produzirá IDs mais curtos. Você pode usar o [playground](/playground) para testar como seus IDs podem parecer.",
	"ttp7pb": "Sim. Tenha em mente que os IDs gerados ainda são strings e podem começar com um zero.",
	"ttk4jh": "Não. {name} não suporta caracteres multibyte para o alfabeto. Isso inclui emojis, bem como muitos outros caracteres.",
	"tt17kp": "A biblioteca pode estender os IDs com caracteres aleatórios para fazê-los parecer mais longos. Isso é útil para que não seja tão óbvio se você está codificando um número pequeno como {min} ou um número grande como {max}.",
	"tt4c25": "A decodificação não é afetada.",
	"ttqp1x": "Sim, a biblioteca aceita um parâmetro de comprimento mínimo que garante que os IDs tenham pelo menos esse comprimento.",
	"ttt88f": "Por favor, note que não há garantia de quão longos serão seus IDs - apenas que eles não serão mais curtos do que o comprimento que você especificar.",
	"tt59mu": "Até certo ponto.",
	"tt7vlr": "Definir o comprimento máximo é impossível porque mais cedo ou mais tarde seus IDs vão transbordar com uma entrada grande o suficiente. É por isso que apenas o parâmetro de comprimento mínimo é suportado, e o comprimento exato ou máximo não.",
	"ttdswn": "Uma lista de bloqueio pode impedir que certas palavras apareçam nos seus IDs. Isso é benéfico porque os IDs gerados devem aparecer em lugares públicos, como o URL.",
	"ttf0wd": "{name} vem com a [lista de bloqueio padrão]({url}) que contém as palavras mais básicas de palavrões e termos inapropriados de várias línguas. É claro que você pode estender essa lista de bloqueio com suas próprias palavras.",
	"tts1jq": "A correspondência de palavras na lista de bloqueio não diferencia maiúsculas de minúsculas.",
	"tt8eh0": "Palavras curtas com menos de 3 caracteres não serão bloqueadas. Palavras com 3 caracteres precisam corresponder exatamente aos IDs. Palavras com 4 caracteres ou mais desencadearão uma correspondência se forem um subconjunto do ID.",
	"ttf01d": "Se as palavras da lista de bloqueio contiverem números (leetspeak), elas só desencadearão uma correspondência se estiverem no início ou no final do ID.",
	"ttcz09": "A lista de bloqueio padrão contém os palavrões mais comuns e termos inapropriados de várias línguas. Você pode encontrar a lista completa [aqui]({url}).",
	"ttxbuw": "Quando o ID gerado corresponde a uma palavra na lista de bloqueio, a biblioteca tenta regenerá-lo.",
	"ttbgyk": "Se todas as tentativas de regenerar o ID falharem, a função de codificação falhará e retornará um erro. O tratamento desse erro fica por conta do usuário.",
	"ttwkle": "A melhor maneira de diminuir o número de tentativas de regeneração é ter um alfabeto mais longo, não definir um comprimento mínimo e fornecer uma lista de bloqueio menor. Fornecer uma lista de bloqueio vazia desabilitará completamente a função.",
	"ttr2ng": "Decodificar IDs geralmente produzirá algum tipo de saída numérica, mas isso não significa necessariamente que o ID seja canônico. Para verificar se o ID é válido, você pode re-codificar os números decodificados e verificar se o ID corresponde.",
	"ttjud7": "A razão pela qual isso não é feito automaticamente é que se a lista de bloqueio padrão mudar no futuro, não queremos invalidar automaticamente o ID que foi gerado no passado e que agora pode corresponder a uma nova palavra na lista de bloqueio.",
	"ttowu8": "Vamos garantir de atualizar o {changelog} se e quando a lista de bloqueio padrão mudar.",
	"ttzo7t": "Você precisa considerar cenários em que uma nova palavra pode ser adicionada à lista de bloqueio padrão. Nesse caso, re-codificar números pode produzir um ID diferente.",
	"tt3i7z": "A melhor maneira de garantir que seus IDs permaneçam consistentes em futuras atualizações é fornecer uma lista de bloqueio personalizada, mesmo que seja idêntica à lista de bloqueio padrão atual.",
	"ttmfhy": "Não, codificar números diferentes produzirá IDs únicos.",
	"ttt85f": "No entanto, devido ao design do algoritmo, a decodificação de IDs aleatórios às vezes pode produzir os mesmos números. A melhor maneira de verificar se o ID é canônico é simplesmente re-codificar os números decodificados e verificar se o ID corresponde.",
	"ttehfa": "{hashids} foi a primeira versão desta biblioteca lançada por volta de 2013. Também produzia IDs curtos, mas usava um método ligeiramente diferente.",
	"ttl3hc": "{hashids} lidava com algumas coisas de maneira diferente.",
	"ttgla4": "Não suportava uma lista de bloqueio personalizada, mas dependia das palavras de palavrão mais comuns em inglês. Também usava o parâmetro {salt} para embaralhar o alfabeto, o que o tornava um pouco confuso, pois a biblioteca não tinha nada a ver com criptografia. Além disso, usava muitos caracteres reservados, o que resultava em IDs mais longos.",
	"ttajo1": "Portanto, decidimos fazer um upgrade e rebranding. O algoritmo foi simplificado, algumas funcionalidades foram adicionadas e os repositórios de código estão todos agora [em um único local]({url}).",
	"ttzolt": "O parâmetro {salt} era usado para embaralhar o alfabeto e nunca foi destinado a estar associado à segurança ou proteção. Ambos {hashids} e {name} funcionam de maneira semelhante à conversão de decimal para hexadecimal, mas com algumas adaptações. Não há criptografia de nenhum tipo, então, para evitar confusão, esse parâmetro foi removido completamente.",
	"ttnq6i": "Não, {name} expande a funcionalidade de {hashids} e tem objetivos e requisitos de design diferentes; portanto, os IDs gerados não são compatíveis com {hashids}.",
	"ttixzo": "Como não há compatibilidade entre {hashids} e {name}, é impossível simplesmente substituir {hashids} por {name}.",
	"ttydl6": "No entanto, você pode mesclar os dois diferenciando a qual biblioteca cada ID pertence.",
	"tt6n93": "Uma das maneiras de fazer isso é pelo comprimento do ID - se estiver mudando para {name}, você pode fornecer um comprimento mínimo mais alto. Outra maneira é anexar/prepender manualmente um caractere personalizado aos IDs recém-gerados.",
	"tth5bj": "Finalmente, você também pode tentar decodificar um ID com {hashids} para ver se é válido. Se não for, decodifique e recodifique com {name} para ver se funciona.",
	"tt0a8s": "Cada implementação de linguagem neste site links para o repositório original de {hashids}, se existir.",
	"tt9t9m": "Se você deseja apoiar o projeto, agradecemos se estrelar nossos repositórios no Github para ter mais visibilidade.",
	"ttpgkb": "Se você é um desenvolvedor e não vê uma implementação de {name} para uma linguagem específica, ajude-nos a converter a biblioteca. O mesmo vale para uma linguagem de programação que não está listada.",
	"ttk57h": "Se você encontrar um bug na especificação ou em uma das implementações, crie um problema ou um pull request com uma correção sugerida no repositório apropriado.",
	"tt1rhp": "Se você fala várias línguas, podemos usar sua ajuda para [ajustar a lista de bloqueio]({blocklist}) e [ajustar as traduções do site]({i18n}) se encontrar algum problema.",
	"tt49l5": "Por fim, se você tem experiência com {hashids}/{name}, ajude a guiar nossa comunidade respondendo a quaisquer perguntas que alguém possa ter.",
	"ttqbpx": "Se você gostaria de portar {name} para uma das seguintes linguagens (ou uma nova não listada aqui):",
	"ttt00f": "Faça um fork do repositório oficial para sua própria conta do Github e implemente [a especificação]({spec}) junto com todos os testes. Você pode reutilizar qualquer um dos READMEs existentes ([exemplo]({example})).",
	"tt5myu": "Assim que a biblioteca estiver pronta, crie um pull request. Depois de aceito, atualizaremos o site.",
	"tt72cr": "Se o repositório não tiver mantenedores ativos, ficaríamos felizes em convidá-lo para gerenciar o repositório e se tornar um mantenedor oficial.",
	"ttdqen": "Se você é um especialista nas seguintes áreas, entre em contato se quiser portar a biblioteca:",
	"ttfsed": "Não encontrado",
	"ttsp7q": "Outros",
	"tt8aj0": "Tentar:",
	"ttfspd": "[{clickhouse}]({url1}) fornece uma função SQL integrada para gerar {name} com parâmetros padrão. A função está disponível desde {clickhouse} [{version}]({url2}):"
}
